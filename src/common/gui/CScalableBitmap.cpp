#include "CScalableBitmap.h"
#include "SurgeError.h"
#include "UserInteractions.h"
#include <iomanip>
#include <iostream>
#include <sstream>
#if MAC
#include <CoreFoundation/CoreFoundation.h>
#endif
#if LINUX
#include "ScalablePiggy.h"
#endif

#include "resource.h"

using namespace VSTGUI;

#if LINUX
static const struct MemoryBitmap *findMemoryBitmap(const std::string& filename)
{
    for (const struct MemoryBitmap *bmp = &memoryBitmapList[0];
         bmp->name != NULL; bmp++)
        if (!std::strncmp(filename.c_str(), bmp->name, std::strlen(bmp->name)))
            return bmp;

    throw Surge::Error(filename + " not found");
}
#endif

// Remember this is user zoom * display zoom. See comment in CScalableBitmap.h
int  CScalableBitmap::currentPhysicalZoomFactor = 100;
void CScalableBitmap::setPhysicalZoomFactor(int zoomFactor)
{
    currentPhysicalZoomFactor = zoomFactor;
}

CScalableBitmap::CScalableBitmap(CResourceDescription desc)
    : CBitmap(desc)
{
    int id = 0;
    if(desc.type == CResourceDescription::kIntegerType)
        id = (int32_t)desc.u.id;

    /*
    ** Scales are the percentage scale in units of percents. So 100 is 1x.
    ** This integerification allows us to hash on the scale values and still support
    ** things like a 1.25 bitmap set.
    */
    
    scales = {{ 100, /* 125, */ 150, 200, 300, 400 }}; // This is the collection of sizes we currently ask skins to export.

    std::map< int, std::string > scaleFilePostfixes;
    scaleFilePostfixes[ 100 ] = "";
    // scaleFilePostfixes[ 125 ] = "@125x";
    scaleFilePostfixes[ 150 ] = "@15x";
    scaleFilePostfixes[ 200 ] = "@2x";
    scaleFilePostfixes[ 300 ] = "@3x";
    scaleFilePostfixes[ 400 ] = "@4x";

#if WINDOWS
    // Only windows uses this integer indexing and knows these offsets
    std::map< int, int > scaleIDOffsets;
    scaleIDOffsets[ 100 ] = SCALABLE_100_OFFSET;
    // scaleIDOffsets[ 125 ] = SCALABLE_125_OFFSET;
    scaleIDOffsets[ 150 ] = SCALABLE_150_OFFSET;
    scaleIDOffsets[ 200 ] = SCALABLE_200_OFFSET;
    scaleIDOffsets[ 300 ] = SCALABLE_300_OFFSET;
    scaleIDOffsets[ 400 ] = SCALABLE_400_OFFSET;
#endif
    
    for(auto sc : scales)
    {
        CBitmap *scBmp = NULL;

#if MAC || LINUX
        std::stringstream filename;
        auto postfix = scaleFilePostfixes[sc];
        filename << "scalable/bmp" << std::setw(5) << std::setfill('0') << id
                 << scaleFilePostfixes[sc] << ".png";
#endif

        /*
        ** Macintosh addresses resources by path name; Windows addresses them by
        ** .rc file ID This fundamental difference means we need to create
        ** distinct names for our bitmaps.
        **
        ** The mapping of filename to id + offset on windows is automatically
        ** generated by the script scripts/win/emit-vector-rc.py.
        */

#if MAC
        scBmp = new CBitmap(CResourceDescription(filename.str().c_str()));
#elif LINUX
        try {
            const MemoryBitmap *memBmp = findMemoryBitmap(filename.str());
            auto platBmp = IPlatformBitmap::createFromMemory(
                memoryBitmapListStart + memBmp->offset, memBmp->size);
            scBmp = new CBitmap(platBmp);
        } catch (Surge::Error err) {
            std::cerr << err.getMessage() << std::endl;
        }
#elif WINDOWS
        scBmp = new CBitmap(CResourceDescription(id + scaleIDOffsets[sc]));
#endif

        if(scBmp && scBmp->getWidth() > 0)
            scaledBitmaps[sc] = scBmp;
        else
            scaledBitmaps[sc] = NULL;
    }

    lastSeenZoom = -1; // we haven't seen a zoom yet!
    extraScaleFactor = 100;
}

void CScalableBitmap::draw (CDrawContext* context, const CRect& rect, const CPoint& offset, float alpha )
{
    /*
    ** CViewContainer, in the ::drawRect method, no matter what invalidates, calls a drawBackground
    ** on the entire background with a clip rectangle applied. This is not normally a problem when
    ** you invalidate infrequently or just have a constant color background. But in Surge we have
    ** a drawn background on our frame and we invalidate part of our UI every frame because of the
    ** vu meter. So every cycle we redraw our entire background into a vu meter sized clip rectangle
    ** which is immediately overwritten by a vu meter which fills its entire space.
    **
    ** There's no good way out of this. We can't subclass CFrame since it is final (yuch).
    ** We cant have the vu meter not invalidate. So we make the bitmap smart.
    **
    ** Well, smart. We make it so that if we are redrawing a rectangle which is positioned relative
    ** to the background at the same point as the VU Meter. That is, a draw at 763+14 on a background
    ** of size 904x542 (ratioed for scaling) gets background supressed.
    **
    ** Am I particularly proud of this? No. But it does supress all those draws.
    */
    VSTGUI::CRect cl;
    context->getClipRect(cl);
    float p1 = cl.getTopLeft().x / rect.getWidth();
    float p2 = cl.getTopLeft().y / rect.getHeight();
    if (fabs(p1 - 763.0 / 904.4) < 0.01 && fabs(p2 - 14.0 / 542.0) < 0.01)
    {
       return;
    }

    if (lastSeenZoom != currentPhysicalZoomFactor)
    {
        int ns = -1;
        for (auto s : scales)
        {
            if (s >= currentPhysicalZoomFactor && ns < 0)
                ns = s;
        }
        if (ns<0)
        {
            ns = scales.back();
        }
        bestFitScaleGroup = ns;
        lastSeenZoom = currentPhysicalZoomFactor;
    }

    // Check if my bitmaps are there and if so use them
    if (scaledBitmaps[ bestFitScaleGroup ] != NULL)
    {
        // Seems like you would do this backwards; but the TF shrinks and the invtf regrows for positioning
        // but it is easier to calculate the grow one since it is at our scale
        CGraphicsTransform invtf = CGraphicsTransform().scale( bestFitScaleGroup / 100.0, bestFitScaleGroup / 100.0 );
        CGraphicsTransform tf = invtf.inverse().scale(extraScaleFactor / 100.0, extraScaleFactor / 100.0);

        
        CDrawContext::Transform tr(*context, tf);

        // Have to de-const these to do the transform alas
        CRect ncrect = rect;
        CRect nr = invtf.transform(ncrect);
        if(extraScaleFactor<100)
        {
            /*
            ** VSTGUI has lots of bugs. One of them is with scaling backgrounds. It never grows a background. 
            ** and it never shrinks a background. Hence the extraScaleFactor. But it does shrink (and only shrink)
            ** the draw rectangle for the background. So when we are at scales < 1 we have over-shrunk the 
            ** extra scale factor. So undo that here. Obviously not great.
            */
            CGraphicsTransform upExtra = CGraphicsTransform().scale( 100.0/extraScaleFactor,100.0/extraScaleFactor);
            nr = upExtra.transform(nr);
        }


        CPoint ncoff = offset;
        CPoint no = invtf.transform(ncoff);
        
#if LINUX
        /*
        ** For some reason alpha = 255 inbound to this function on linux (and maybe on
        ** mac and windows) but unlike mac and windows that misscaling actually causes
        ** draw errors on linux because of the comparison in cairocontext.cpp at line
        ** 396 (the (if (alpha != 1.f )) so hand-rescale it here for now
        **
        ** FIXME: Find out why alpha = 255 inbound here in VSTGUI Linux.
        */
        if (alpha==255)
            alpha = 1.0f;
#endif

        scaledBitmaps[ bestFitScaleGroup ]->draw(context, nr, no, alpha);
    }
    else
    {
        /*
        ** We have not found an asset at this scale, so we will draw the base class
        ** asset (which as configured is the original set of PNGs). There are a few
        ** cases mostly involving zoom before vector asset implementation in vst2
        ** where you are in this situation but still need to apply an additional
        ** zoom to handle background scaling
        */
        CGraphicsTransform tf = CGraphicsTransform().scale(extraScaleFactor / 100.0, extraScaleFactor / 100.0);
        CDrawContext::Transform tr(*context, tf);
        CBitmap::draw(context, rect, offset, alpha);
    }
}
